Introduction
Hi. This is Bryan Hansen, and in this module, we are going to look at the Factory Method designed pattern. The factory method pattern is in some ways the opposite of the singleton pattern and it probably is the second most used creational design pattern.

Concepts
The concepts when choosing a factory are that it doesn't expose instantiation logic. The client knows next to nothing about even the type of object that is being created. It is able to do this by deferring the instantiation or a creation logic to the subclass. All the client typically knows about is a common interface that the factory exposes. Factories are oftentimes implemented by an architecture or a framework and implemented by the user of that framework. This establishes a contract for how things will be implemented within the framework, but allowing flexibility for the end user to define how it can be implemented. Examples of this in the Java API are the Calendar, ResourceBundles, and a NumberFormat. Oftentimes people think that Calendar is a singleton because it has no arguments or a no arguments constructor, and factory methods can have arguments. The difference is that a calendar can return different subclasses of the calendar and the client is unaware, whereas with a singleton you are just getting a single instance of that implementing class.

Design Considerations
I view the factory as almost being the opposite of the singleton. The factory is responsible for creating instances and managing the lifecycle, at least the creation part of the lifecycle. Objects created are referenced through a common interface. Factories will also reference multiple concrete classes or implementations, but the client is unaware since they are referenced through the common interface. The other key design principle is that the method to request an object is typically parameterized. These parameters are what are used to determine the concrete type. The UML diagram on the left shows the Factory, which is an implementation of the factory pattern. It has a factoryMethod, which will call and then return an interface to whatever object type we are attempting to build. The Factory itself refers to a concrete implementation that does the actual instantiation of our ConcreteObject. So we have our Factory class or our Factory abstract class that has a static factoryMethod that we are going to call, and based off of those parameters that we pass in, we're going to call a concrete instance that's going to return the object type for us.

Pitfalls
The pitfalls of a factory method pattern are namely complexity. You will notice compared to the other creational design patterns the factory pattern is almost double the amount of code to demonstrate it. The part that most people often get wrong when implementing the factory is that creation doesn't take place in the factory itself, but rather in the subclasses of the type of factory method we are creating. The factory method pattern is also the pattern that's generally not refactored into. You need to design from the beginning that it's going to be a factory and then plan accordingly.

Contrast to Other Patterns
To contrast the factory pattern with another pattern, we're actually going to do the same comparison we did with the singleton. The singleton and the factory are almost the exact opposite of one another. The singleton returns the same instance. It has one constructor method with no arguments and no interface and no subclasses typically, whereas the factory returns various instances and has multiple constructors or arguments that we can add to a constructor type method. It is very interface driven, and when I say interface driven, I don't always mean that we're implementing an interface, but it can be an abstract class or a contract, it's very contract driven. There are always subclasses involved. You can't have a factory pattern without having some fashion of a subclass involved. And it's easily adaptable to your environment, so a lot of frameworks are written using the factory pattern where you implement them per environment as you want to use them.

Summary
Just to recap the factory pattern and how it differs from some of the other patterns, it is parameter driven, in fact, this is one of the few creational patterns that is parameter driven. It solves complex creation in a different fashion than all the other patterns. So we had the builder that was involved with enforcing a contract with our constructor and multiple parameters, but it didn't support parameter driven construction meaning that if we wanted to choose a type at run time, the factory is really the only one that deals with that. One of the drawbacks of the factory is that it can be a little bit complex and it really is the opposite of a singleton. So if you're looking at a singleton, and it doesn't seem like it's the right fit for it, you probably need to be looking at a factory. Most of these patterns stand on their own, so unlike traditional courses we do here where we try to talk about the next module that's going to come up, all of these patterns will stand on their own two feet, except for the factory has kind of a cousin, which is the AbstractFactory, and that is the next module we're going to cover in this series is the AbstractFactory and how that applies to the factory method pattern.
