Introduction
Hi. This is Bryan Hansen, and in this module, we're going to look at the abstract factory design pattern. The abstract factory is very similar to the factory method pattern, and in fact, is typically implemented as a factory of factory patterns.

Concepts
The concepts when choosing an AbstractFactory are that it is a factory of factories. Although it can be implemented without using the factory method pattern, more often than not it is. It is typically summarized as a factory of related objects. It also takes the concept of a common interface a step further. The common interface is implemented throughout the AbstractFactory and its underlying factories, and just like the factory method pattern is deferring the instantiation or creation logic to subclasses as well. Examples in the Java API are the DocumentBuilder from the XML APIs. There aren't a lot of other examples because it is often implemented in frameworks and not just in the standard Java API.

Design Considerations
The design principles when implementing an AbstractFactory are that you want to group a collection of factories together. The factory is still responsible for the lifecycle itself, and it has a common interface that is carried throughout the AbstractFactory, as identified on the UML on the left here, down through the ConcreteFactory, and finally to the implementing class below. Just like the factory, there are concrete classes that are finally returned from the underlying factory. The AbstractFactory also has parameterized create methods just like the factory method pattern does as well. One key point is that the AbstractFactory is typically built using composition where that is not the case with the factory method pattern, so one very key distinction there. The AbstractFactory itself implements a very good use of objects for development through composition.

Pitfalls
Some of the pitfalls with the AbstractFactory are its complexity. The AbstractFactory is the most complex of the creational design patterns and is definitely more difficult to implement. At some point in development, there is a runtime switch. The client has some influence what we do with the switch, and this makes some people afraid that the client knows too much about what is going on. It isn't a big issue, it can just be a hang up for some people architecturally. Although other patterns sometimes do this, it is definitely a pattern that contains other patterns. It's also very problem specific. Other patterns solve a broader problem, say for instance like the singleton, it just limits it to a single instance where the AbstractFactory is a grouping of factories. Another pitfall is that it usually starts off as a factory and then is refactored to an AbstractFactory. Most people don't often visualize using the AbstractFactory to begin with.

Contrast to Other Patterns
Rather than contrast the AbstractFactory with another type of creational pattern, I'm going to compare it with the factory pattern. A factory returns various instances and allows multiple constructors. It is interfaceâ€‘driven and it is adaptable to each environment more easily. All of these hold true for the AbstractFactory as well. It is implemented with a factory, it hides the underlying ConcreteFactory, and the AbstractFactory adds one more layer of abstraction to our environment. Another key difference between these two is that the AbstractFactory is typically built through composition. So, all of these features of the factory apply to the AbstractFactory with these additional, nice added bonuses of the AbstractFactory. It hides what factory we're using. It also abstracts our environment built with composition. I should note, though, it doesn't have to be implemented with the factory, it just usually is 99% of the time.

Summary
To recap, the AbstractFactory is a group of similar factories. It is quite complex a lot more so than the other creational design patterns that we've gone through. It is heavily abstracted. We utilize interfaces, subclasses, composition, and just general software contracts to develop this pattern and achieve various levels of abstraction. We typically don't do this with other design patterns. And it's typically written as a framework pattern meaning that this is part of a larger framework. Where the other patterns may solve a particular problem and do it in a generic way that we can use it anywhere in our code, the AbstractFactory is typically built as part of a larger framework inside of our code. The AbstractFactory is the last of the creational patterns that we have gone through in this Creational Design Pattern Series if you've been following these in order. I urge you to look at this in relation to the factory, even though it can be implemented with something else, this is usually written with the factory pattern in mind.
