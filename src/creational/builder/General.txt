Introduction
Hi. This is Bryan Hansen, and in this module, we're going to look at the builder pattern. The builder pattern is a pattern that people often use, but rarely create their own. It is a great pattern for handling the construction of objects that may contain a lot of parameters, and we want to make the object immutable once we're done constructing it.

Concepts
When considering a builder, you want to focus on whether or not the construction of an object is complex. By complex, we are specifically talking about lots of arguments for a constructor, or lots of setters, and then guaranteeing a contract of how that object gets built. Another key concept that is often overlooked is that you can force immutability on an object once the construction is finished, which you can't necessarily do with just a bunch of setters. This just helps further enforce our contract. Examples of this in the Java API are the StringBuilder, probably one of the most common ones out there, which is honestly one of the best examples of a builder pattern; the DocumentBuilder, which I feel like illustrates how this pattern can be used on a complex object creation; and then a Locale.Builder, which is just another good example of this pattern and how it takes various parameters as part of its construction.

Design Considerations
The builder pattern solves a very common problem in object oriented programming and that is determining what constructor to use. Oftentimes, people create multiple constructors, and it can become difficult to manage. The creation of multiple constructors with each parameter variation is called a telescoping constructor. The builder pattern helped us overcome this by handling that construction with an object and rather than by parameters. The builder is typically written with a static inner class. The reason for this is that it returns an instance of the object that it is building. It doesn't negate the need for constructors and rather works in unison with those to call the appropriate constructor based off of its state. The builder pattern can negate the need for the job of being antiâ€‘pattern of exposing setters for every parameter that we could pass in. Since Java 1.5, we can take advantage of generics where it warrants to utilize a builder to expose various types of objects. But this is often not a necessary feature.

Pitfalls
The builder pattern really doesn't have a lot of negative things about it, so there really aren't that big of pitfalls, but maybe just some things to consider when choosing to implement it. Objects created with the builder are typically designed to be immutable. The pattern itself is also typically implemented with a static inner class, again, not a big issue, and as we demonstrated with the StringBuilder API, there are ways around that. Unlike the prototype pattern, it isn't something that is usually refactored in after the fact, it does add a little bit more complexity to our implementing class over what could have been done with just a constructor, but without some of the nice features of the builder patterns. Adding to the complexity is that people are typically not used to an object returning itself for each subsequent call.

Contrast to Other Patterns
To contrast the builder pattern, let's compare it with the prototype pattern. The builder pattern is designed to handle complex constructors. There's typically no need for an interface, but you can implement the builder with one if you want. It can be implemented with a separate class, even though it is typically implemented in the class that it is building. And since it is implemented in a separate class, it can easily integrate with legacy code without needing change it. The prototype, on the other hand, is implemented around a clone method and trying to avoid the need to call a complex or costly constructor. Since the clone method is focused around member variables and constructors, it is implemented inside the class that it is trying to clone. This can make it difficult to implement in legacy code. Both of these patterns, though, are focused on complex constructors within one class. Their approach, though, is quite a bit different to solving that problem. So the builder tries to work with complex constructors where the prototype tries to avoid having to call them again.

Summary
Let's just recap what we covered with the builder pattern. It is a creative way to deal with complexity surrounding constructors in the creation of objects. It is fairly easy to implement, I would say almost as easy as the singleton to implement if done correctly. There are very few drawbacks to it, in fact, you kind of have to go out of your way to find some drawbacks with the builder pattern. And lastly, you can refactor it in with a separate class. Although it's typically implemented within itself, there's no reason that static inner class has to be a static inner class. It can be an external class that we go ahead and create what we want with our builder and then just call the constructor or whatever we want regarding setters or whatnot on the class that we are the builder for.