Introduction
Hi. This is Bryan Hansen, and in this module, we are going to look at the singleton design pattern. The singleton pattern is one of, if not the most, heavily used design patterns because of its simplicity to implement and the type of problem that it solves.

Concepts
The concepts when choosing a singleton are that it guarantees only one instance is going to be created. It also guarantees the control of a resource. Since this is a creational design pattern, the instantiation of it is all controlled through the implementation of the pattern. Although it doesn't have to be, it is usually lazily loaded. This ties in nicely with it being a creational pattern. Examples of this in the Java API or commonly used frameworks are the runtime environment, logger, but depending on the implementation this could be factory instead of singleton, and we will discuss this in more detail later, Spring Beans, if you've used the Spring framework at all, you will quickly learn that all Spring Beans are by default singletons. And a fourth example are graphics managers. Typically when you're using a Graphics API of any kind, you're going to get an instance of your graphical environment, and we only want one of those instances at a time.

Design Considerations
The singleton is responsible for creating itself and managing its lifecycle. It is static in nature, although it is not implemented using a static class typically. The reason for not using a static class is that it needs to be thread safe, and static doesn't necessarily guarantee this for us. There is a private instance of a singleton, hence the minus sign or hyphen in the UML. There is also a private constructor that is marked the same way. This is because we want the singleton itself to call the constructor and nobody else. There are no parameters, and if you require parameters, that is typically a factory pattern and violates the rules of a singleton.

Pitfalls
Some of the pitfalls of a singleton are that they are often overused. Once people discover the power and simplicity of this pattern, they have a tendency to make everything a singleton when it doesn't necessarily need to be. Although there aren't generally performance problems with singletons, if you make everything a singleton, it will slow your application down. Since singletons don't expose an interface and have private constructors, as well as private member variables, they can often be difficult to unit test. If you aren't careful when implementing it, they're not thread safe. Oftentimes, people start off with a singleton that's static, like we demonstrated, and it ends up morphing into something else and can oftentimes be confused for a factory. They start making the getInstance method take parameters. A rule of thumb is that as soon as it needs an argument in that method, it is not a singleton anymore, but rather a factory. Although not a pitfall, the java.util.Calendar is not a singleton, it is actually more of a prototype pattern because you are getting a new unique instance every time you call the getInstance method. People often confuse this, though, because it uses that identifier of getInstance, which is typically associated with a singleton.

Contrast to Other Patterns
To contrast the singleton with another design pattern that it's commonly confused with, the factory, let's go through the two side by side so you can see the differences. A singleton will return the same instance every time. There is a one constructor method with no arguments, and notice how I label that as constructor method. The constructor is always private so you can't get access to it, so we have to access that through a construction method. And then there is typically no interface. Since this is a private constructor and a private instance inside of it, we don't expose an interface to help us adapt to different types of objects return. A factory, on the other hand, returns various instances, and, as the name implies, it returns multiple objects of various types. It also has multiple constructors because we're asking for those various types. There's different construction methods for us to get those instances back. It is usually interface driven. It's the opposite. We want to abstract out the back end and some of those things that we're returning so we usually do expose an interface with a factory, so it's a lot easier to unit testing and a lot easier to work with. It also has the ability to adapt to environments more easily than the singleton does. So, when you're looking at a singleton and it's not quite fitting, think about the factory and what the factory brings to the table, and some of these comparisons may help you in choosing a factory over a singleton, or a singleton over a factory.

Summary
To summarize the singleton pattern, we use this pattern when we want to guarantee that there's only one instance of an object inside of our application. It's very easy to implement, and it's even easy to make thread safe if you just spend a few minutes wrapping the construction of that object. It solves a very well defined problem where we only want to have one instance of that object inside of our application. But it can be abused quite easily. It's usually the most abused design pattern that we see out there in applications. Not everything needs to be a singleton, not everything needs to be guaranteed that there's one instance. So use it wisely and think about what you're needing to solve with this, and don't confuse it with a factory pattern as well.