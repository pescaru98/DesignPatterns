Introduction
Hi. This is Bryan Hansen, and in this module, we are going to look at the prototype design pattern. The prototype pattern is used when the type of object to create is determined by a prototypical instance, which is cloned to produce a new instance. Oftentimes, the prototype pattern is used to get a unique instance of the same object.

Concepts
The concepts when choosing a prototype are when you are trying to avoid costly creation. Choosing a prototype is sometimes not as cut and dry as other patterns. I personally feel that it is often a refractory pattern and not a pattern that people usually think of upfront. Unlike the singleton, where you start off knowing that you want only one instance, you usually don't think of it in terms of something being expensive to create. Prototypes also avoid subclassing. Usually you create an instance of the actual prototype that you are trying to work with. The next concept can be a little confusing, too, but they typically don't use the keyword new. The first instance created might use the keyword new, but after that they are cloned. Although it can be implemented without it, there are good reasons to create an interface for your prototype instance. Prototypes are also usually implemented with some sort of registry. The original object is created and then kept in our registry. When another object is needed, we create a clone of that object from the registry. An example of the prototype pattern from the Java API is the java.lang.Object clone method. Although it is not all of a prototype pattern, it is definitely the basis for what we will design our prototype patterns around.

Design Considerations
The prototype pattern is an interesting pattern in that it is just changing the way that we call the keyword new. If an object is expensive to create, but we can get what we need by copying the member variables, then the prototype is a great fit. The prototype typically implements the Clone/Cloneable method and interface. This enables us to avoid using the keyword new. Typically, if our creation is expensive, it is going to be when we call the keyword new. Although we are using the clone method and essentially just making a copy, each instance is still unique. Different from patterns like the builder, costly construction is not handled by the client. In fact, I would say that the builder is the opposite of the prototype pattern. Different from the singleton, you can utilize parameters in the clone if you need to, but typically you don't. As the architect, you can choose whether you want to do a shallow versus deep copy. A shallow copy just copies the immediate properties, whereas a deep copy will copy any of its object references as well.

Pitfalls
What are some of the pitfalls of a prototype? Well, prototypes are often not used. This is a difference from the singleton pattern, where people usually overuse it. Another pitfall would be that you typically have to use it with another pattern. A loose definition of a framework versus a pattern is that if a pattern contains other patterns, it is a framework. This isn't always true, but it makes you sometimes question the use of a prototype because we typically have to implement that with some sort of registry. Lastly, a lot of times you want a deep copy and the clone interface only does a shallow copy. You can, of course, implement the functionality of a deep copy yourself, but that requires more coding yourself, and people start to second guess the validity of the pattern and whether it's solving anything for them.

Contrast to Other Patterns
Since it's easy to always just pick on the singleton pattern, let's compare the factory with the prototype pattern. A prototype is focused on lightweight construction, either through a copy constructor or using the clone method, like we demonstrated in our two examples. You can choose to do a shallow versus deep copy, but really in the end, you're looking at just creating a copy of yourself, even though in our one example we did an abstract class with a sub item, we're looking at creating a copy of whatever item instance we are. So we were a movie and we got copies of a movie, we weren't looking for different objects based off of what we were trying to do. The factory, on the other hand, is focused on dealing with flexible objects based upon your request. you can utilize multiple constructors instead of just the clone method, and it also utilizes creating a concrete instance of an object, and it is a fresh instance since we're utilizing the keyword new, so there aren't any programmatic defaults by nature. You remember back in our demo, we had set a default URL on a price and a run time, things like that; typically, that's not a feature that we program into a factory pattern.

Summary
To summarize the prototype pattern, we are using this pattern to guarantee a unique instance every time we ask for it. A drawback or a side note on it is that it's often something that gets refactored in later, and that's because we're usually looking for it to help us with some performance issues inside of our application. So if we have an application, it's creating a lot of objects, we want to go ahead and implement this pattern so that it can help us obtain these objects faster without the heavyweight or overbearing nature of creating then using the keyword new every time we want an object. And lastly, I would note, don't always just jump to a factory. Look at a prototype to see if it will solve your problem with your current situation because a factory can often lead to other things that a prototype is nicely suited for.