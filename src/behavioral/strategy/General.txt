Introduction
[Autogenerated] Hi, This is Brian Hansen and in this module where you're going to look at the strategy design pattern, the strategy pattern is a behavior pattern that is used when you want to enable the strategy or algorithm to be selected at runtime. Let's look at the concepts when choosing this pattern.

Concepts
[Autogenerated] the concept surrounding why you would choose the strategy pattern or that you want to, or see the need to eliminate conditional statements in your application. The strategy pattern encapsulates the algorithm options in the individual classes that eliminate the conditional statements in your application. Another key point of when you would choose the strategy is if it's difficult to add new strategies or cases inside your application. When using this pattern, the client is typically aware of the strategies that are available and usually chooses the strategy that we're ultimately going to use in our application. A great example of this pattern in the job a p I is Java Util comparator. The comparator is used when we want to implement various comparison strategies in our application for passing into a sort method. Let's look at the design of the strategy pattern now

Design Considerations
[Autogenerated] the design of the strategy could be implemented with an interface, but typically it is usual izing, a abstract based class. All of the concrete classes are then implemented per strategy, where each concrete class will then implement the algorithm that is unique to that strategy. A key point with the strategy pattern is that we want to minimize, if not eliminate, if else condition ALS from her application. A key point with the design of this pattern is that the client knows about the strategies. But other strategies don't necessarily know about each other. The pieces of the UML diagram are a context, strategy and concrete strategy implementations. Let's look at that UML diagram now.

Pitfalls
[Autogenerated] Now that we've seen the strategy pattern in action, let's talk about some of the pitfalls of it. The client does have to be aware of the concrete strategies that are available. This is quite a bit different than the state where the client didn't have to choose what state it was in. Strategies have to be chosen one of the other drawbacks, or that there is an increased number of classes in the application. It really isn't a big problem because we usually don't have more than a few strategies in our application, but it does add a little overhead. The maintenance of our application is much easier, though, and definitely worth this small overhead. Speaking of the state pattern, let's contrast the strategy with state pattern to Seymour of the commonalities that they share

Contrast to Other Patterns
[Autogenerated] to contrast the strategy pattern. Let's compare it with the state. The strategy pattern is almost identical to the state pattern, but it's focuses different and that it's for algorithms or strategies instead of transitionary states. It is interface based, just like the state pattern with mud. Major difference, though, is that strategies don't know about their next state. In fact, they are independent of one another, also similar to the state. There is a class per algorithm instead of a class per state. The state pattern, on the other hand, is interface base, just like the strategy and has a collection of concrete states that we can transition to. A state only knows aboutthe next state that it can transition to, and each state is contained in its own class. So they're very similar a class per state or a class per algorithm. They're both interface based. The few major difference is is that he state knows about the next day that is going to transition Thio and the strategy doesn't know about other alternative strategies. The major difference, though, in my opinion of the strategy, is that the client typically knows all of the strategies that are available to it where it doesn't necessarily know all of the states that it can be in. We can request it, but it doesn't assign that up front like it does with the strategy.

Summary
[Autogenerated] let's recap what we've learned with the strategy pattern. We want to utilize this when we want to externalize algorithms inside of our application. It should also be known that the client knows about the different strategies that we can implement inside of her application. It doesn't have to know about all of them, but it typically does. In the case of the strategy pattern, there is also a class per strategy. We typically utilized this pattern when we want to reduce conditional statements inside of our application based off what we're choosing to utilize to solve a problem. The next pattern we're going to look at is the template pattern, and we kind of got a glimpse of the template pattern when we looked at our solution of the Comparator and how that utilize strategies. We're going to see a great example of this with the template pattern
