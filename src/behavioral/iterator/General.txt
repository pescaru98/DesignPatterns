Introduction
[Autogenerated] Hi. This is Brian Hansen. And in this module, we're going to look at the generator design pattern. The generator pattern is a great pattern for providing navigation without exposing the structure of an object.

Concepts
[Autogenerated] the concept surrounding why you would choose the Liberator pattern are that you need to traverse a container in Java and most current programming languages. There's the notion of a collection list maps sets are all examples of a collection that we would want to traverse historically have used a loop of some sort and an index into your collection to traverse it. In the case of the generator, we don't expose Thea underlying structure of the object that we want to navigate. Navigating various structures may have different algorithms or approaches to cycle through the data the IT aerator de Couples. The data from the algorithm used to traverse it generators air also sequential in nature. And this is an interesting concept because not all objects have a sequential set of data. The generator handles the navigation in an order that best resent represents its sequence. Examples of this in the job, a p i. R. The built in it aerator interface. This is such a pivotal part of the language that Java has decided to build in an interview later interface for us to use across all of our containers and collection that needs some sort of navigation There is also an enumeration in new Marais. Shin predated it aerator and is now simply just a copy of the functionality of the operator interface. Let's look at some of the design considerations when choosing and generator.

Design Considerations
[Autogenerated] the design of the Liberator is interface based. Whichever object you want to reiterate over will provide a method to return an instance oven iterated from it. It follows a sort of factory method pattern in the way that you get an instance of the IT aerator each generators developed in such a way that it is independent of another. It aerators don't know about other it aerators, but they are fell fast. Fell fast means that to Liberators. Can't modify the underlying object without an air being thrown coincidentally and numerator are fell safe, which means it is built in a way that they can't be used to fell. They're pros and cons to both, but they decided in the job a p I to utilize a fell fast approach rather than a fail safe approach for the it aerator pattern. The peace of the UML diagram are simply an operator interface and an instance of a concrete generator from the container. Let's now look at that UML diagram

Pitfalls
[Autogenerated] Now that we've seen a couple of working examples and created her own, what are some of the pitfalls of innit? Aerator? Well, if you haven't noticed and it would be pretty hard not to because we've discussed it a couple of times. You don't have access to an index of any sort. If you want to get an element of a certain position, there is no way to do that without just iterating through and stopping on that object in the case of sets and maps and some of the other collection. So there isn't a method for you to grab an element at a certain position, So this is somewhat of a moot point. The Basij aerator interface in Java is also on Lee Yoon a directional. It can only go forward. Some of my limitations, though, offer bidirectional access. So if you've noticed the list, it aerator not just the generator that we're using to the list it earlier. It has a forwards and backwards capability built into it. I don't give you the wrong impression here either. And in most cases, Thean Aerator is the most efficient solution to looping through an object bid in a couple of select scenarios, the generator may be slower and just slightly slower than using an index and looping through it. I should note that larger, looping instances the generator is almost always more efficient. I don't wanna say it always is because someone will prove me wrong. But in every scenario I've seen in every test ran, the generator is the most efficient way to go through a large collection of objects.

Contrast to Other Patterns
[Autogenerated] with all of the other patterns we've covered. We have contrasted the pattern with another to show its strengths. The generator is a little different than others, though, and stands on its own feet to have something to compare it to. Let's look at the traditional four loop instead, as we've already talked about some of its strengths and weaknesses compared to the generator, the generator is interface based, and by doing so, helped us remove the Traverse A LL algorithm from the client. There is not an index available. Yeah, it doesn't seem to be much of an issue, especially when we're iterating over some of the collections that don't have a dot get at a certain index. It also helps us with concurrent modifications. So two things trying to modify that collection at the same time the four loop pushes all of it's true, traverse a ll code to the client. So this is, ah, huge change. You'll notice that we had an algorithm that was contained in the repositories as we generated that anonymous in her class inside that object, and it kept track of indexes and how we may or may not navigate over that object It also exposes an index which could be beneficial or not, depending on your usage of it. It doesn't change the underlying object cause you're dealing with that object. It also doesn't allow you to work with the four each syntax. If you're going to be using the four each syntax, you have to be utilizing an object that is implementing the literal interface. And that shorthand is really nice. And it typically is slower in most situations the way that we're navigating, using the four loop so the generators a little faster, and it handles things like concurrent modification as well, a cz keeping that algorithm contained from the client. So keeping your clients simpler for both to use. Both work well. There's pros and cons to each. But many people often overlook the it aerator early on because they knew how to deal with a four loop. There's a lot of scenarios where that traitor is a much better for iterating than that for Luke

Summary
[Autogenerated] Let's recap the IT aerator. It's an efficient way to traverse an object. We've shown that both in speed as well as keeping your client simpler than what may be done with just a simple four loop. It also hides the algorithm from the client, so that simplicity for your client is contained within the algorithm that you have coated in the container. You're creating an illiterate or four, so it helps us simplify that client. It also lets us take advantage of the new four H syntax that was introduced in Java 15 which definitely simplifies iterating over that object in a four loop or some of the various methods using a wild loop. The next batter we're going to look at is the mediator pattern, which is used to handle how objects interact with one another.
