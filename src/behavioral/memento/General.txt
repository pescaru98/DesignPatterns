Introduction
[Autogenerated] Hi, This is Brian Hansen. And in this module, we're going to look at the memento design pattern. The memento pattern is used to externalize an object state, usually to provide rollback functionality.

Concepts
[Autogenerated] the concept surrounding why you would choose the momentum pattern or that you need to restore an object to a previous state. We achieved this by Externalizing and objects internal state so that that object could be returned to it later. We do need to be careful to not violate encapsulation while implementing this pattern. Typically, we would use this pattern to implement, undo or roll back functionality inside of an application. Another benefit of the memento is that it shields complex eternal internals from other objects. Examples of this in the job a p i. R Javi you till date. The date object is internally represented by a long value, so we can easily return the date object to its previous state by setting it back to that long value. A better example, though, is probably java dot io dot serialize Herbal serialize herbal allows you to implement any object to have its state recreate herbal. Let's look at this design associated with this pattern

Design Considerations
[Autogenerated] the design of the memento is class based. There are three roles in this pattern. The originator, which is the object that we were wanting to create a copy or save point of the originator creates an actual memento. The next role is that of the caretaker. The caretaker is what manages the copies or Mementos that we have created. Think of it is the list of undoes available in your menu and then, finally, the memento itself. The momentum represents the copy of the originator that we want to store. The memento consists of what's often termed as a magic cookie. The magic cookie is the combination of fields that it takes to recreate or copy the state of the object, and it is stored inside the memento. It isn't an actual object, but you will often see people refer to it when discussing the memento, the pieces of the UML diagram or what we already discussed the originator caretaker, a memento. Let's go ahead and look at that UML diagram now

Pitfalls
[Autogenerated] now that we've created our own memento, let's look at some of the pitfalls of using this pattern. It can be expensive. If the memento is a large copy of the originators data, we might incur a lot of overhead with each copy that we store. The caretaker, although maybe simple and lightweight, needs to consider deleting that history or how much of the history it should keep around. You also need to be careful not to expose originator information. State needs to be transitioned to the memento, but not outside of their. In our example, we had methods for the access er's, but we didn't convey what our state was. Two other objects, just the memento.

Contrast to Other Patterns
[Autogenerated] to contrast the memento pattern. Let's compare it with the command pattern. The memento is used to capture ST. Each state that we capture is independent so that we can roll back or recreate it in the future. Memento is also focused on building a history with the caretaker object. The command, on the other hand, is very similar, almost identical in fact, to the memento pattern. But it is focused on requests rather than the state of an object instead of independent state. It's focused on independent requests. The main difference with command is that a lot of people implement the command without thinking of history. It is available, but typically not the focus of the request of this object. History is just a side benefit benefit. Typically, when using the command all the pieces of their though the option is available, most people don't utilize it.

Summary
[Autogenerated] Let's recap what we've learned with the memento it's used to capture ST. We have to be careful because it can get heavy with history. If we have a lot of Mementos that we've stored, or it's a large amount of data that we're copying for that state, they can get quite large. We use it to recreate state of an object. So once we've captured it, we can then return an object to that state. And it is very similar, if not almost identical, to the command, but with a different emphasis on history and state rather than requests. The next pattern that we're going to look at is the observer pattern, which is one of my favorites, and one of the very first patterns that I learned when trying to figure out the power of design patterns.
