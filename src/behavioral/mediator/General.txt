Introduction
[Autogenerated] Hi, this is Brian Hansen, and in this module, we're going to look at the mediator design pattern. The mediator pattern is used to define how objects interact with one another without having them refer to each other explicitly. Let's look at the concepts when choosing this pattern.

Concepts
[Autogenerated] the concept surrounding why you would choose the mediator pattern or that you need to achieve loose coupling between objects. This is present when we're dealing with a set of well defined objects that communicate in complex ways. Oftentimes their spaghetti code between objects that make loose coupling seem impossible and makes it tough to create a reusable components. Because of inter object communication, it's simply acts as a hub or a router in your application and which all communication will be routed through examples of this in the job, a p i. R the Java Util timer class, the timer class mediates through its schedule methods. Also, the Java laying reflect method class has an invoke method that allows us to mediate objects that were reflecting upon. Let's now look at the design of the mediator

Design Considerations
[Autogenerated] the design of the mediator is interface based with a concrete class, although it could be implemented as just a class. Utilizing the interface gives us the option of cycling out. The various mediators based on the situation typically would want to do this for variances across different platforms that were deployed on. The mediator often minimizes inheritance and our application because it is handling the communication rather than classes inheriting functionality. The mediator also knows about all the colleagues rather than colleagues knowing about each other. Pieces of the UML diagram are the mediator and a concrete meteor. Let's look at that UML diagram now.

Pitfalls
[Autogenerated] Now that we've created our own instance of a mediator, what are some of the pitfalls of it? Well, you have to be careful not to create a deity object. You can easily build a mediator that is everything to everybody and becomes unruly. This usually isn't a problem, but you can see how, by adding different scenarios, it can become large rather quickly. The mediator structure can limit subclass ing, too, although, as we discussed in the design section, you convey eloped mediators to extend and provide various mediators for various situations. But those are usually used for platform differences. They can also be a little confusing whether or not you should use this instead of the command pattern. This is why I went out of my way in the demo to show the command pattern in conjunction with the mediator, as they feel, is a really good use of this pattern. Let's compare this with some other patterns, though, to solidify some of these concepts

Contrast to Other Patterns
[Autogenerated] to contrast the mediator pattern. Let's compare it with the Observer. The mediator defines how objects interact with one another, and its intent is to decouple objects by eliminating references to each other and instead just have a reference to the mediator. It is also more specific, and I'll explain what I mean by specific here in a second when I compare it with the Observer. The Observer, on the other hand, is a one too many broadcast. Instead of defining interaction like the mediator it broadcast to all listeners, they choose whether or not they want to do something with it. It also focuses on object to couple ing just in a different way. By using that broadcast using this approach, it makes things more generic, adding, this feature requires just becoming another listener rather than modifying the actual mediator.

Summary
[Autogenerated] to recap what we've learned about the mediator. It helps us achieve loose coupling between objects, and it does this by simplifying the communication between those complex objects. You do have to be careful of mediator complexity. You can see how, if we add too much to it at once, that it could become this unruly object for us to maintain, and I like to use it with the command pattern rather than in lieu of the command pattern. But they do stand on their own two feet, and you don't have to use them together. The next pattern we will look at is the memento pattern, which is a great pattern for providing rollback functionality in your application.
