Introduction
[Autogenerated] Hi, This is Brian Hansen. And in this module where you're going to look at the command design pattern, the command pattern is a behavioral pattern that lets you encapsulate. Each request is an object. There are a lot of reasons as to why you'd want to do this. Let's look at some of those concepts.

Concepts
[Autogenerated] the concept surrounding why you would choose the command pattern or that it encapsulates. Each request is an object. If you have dealt with or are going to work with a large system, you'll quickly find that the business logic and functions inside that system can be very complex to maintain a debug if they're all just added in one file. Another key reason for choosing this pattern is that each call back a request is now object oriented instead of just another method added in sight of that growing class. Maintain ability is also increased because the sender is decoupled from the processor. This will enable the system to be more flexible and grow over time, often times, but not the only reason. You will use a command to add undo functionality to your application. The entire request should be contained within the command and then could be rolled back. Examples of this in the job a P I. R implementations of java dot laying dot rentable each implementation. It adheres to the principles of the command pattern. Another example is any of the Java ex dot swing, the action implementations Years ago, swing actions were probably the first place that I personally used this pattern and have since used it in many Web frameworks and applications that I've written on my own.

Design Considerations
[Autogenerated] the design of the command is a little different than some of the other patterns and is sometimes argued that it breaks the principles of, oh design because there is an object per command, A command is a verb, and objects usually aren't verbs, but rather the methods inside them. But people have seemed to relax their view on this. The main contract of the command is the command interface, all implementations of actions or commands inside the framework will implement this interface and in its simplest form, just contains an execute method. This method is where all of the action is performed. In the case of an undue feature, though, the interface will also contain an UN execute or undue method. But this isn't required to adhere to the principles of this pattern. Advanced implementations of this pattern make use of reflection to completely decoupled the client from the receiver or processor using a callback. Most examples you see, though, are simpler than this version, and we're going to look at various examples is to see howto best exercise this action and implement it in your day to day use. The pieces of the UML diagram are a command and invoke er and a concrete command. Let's go ahead. Look at that UML diagram now

Pitfalls
[Autogenerated] what are some of the pitfalls of a command. It's typically used with other patterns to be more mature. The dependence on other patterns isn't necessarily a bad thing. It just requires more knowledge on the developers part. I also often see people struggle with the use of multiple commands. Frequently, I see people make the mistake of duplicating logic in another command. A better way to do this is either the use of a composite pattern as we demonstrated or commands. Combined with the chain of responsibility pattern for undue functionality, you may want to look it using the memento pattern to handle state. If you're tracking of objects needs to store a history, you may need to also look at the prototype pattern for creating copies of commands to store on a list to get a better idea. When we shouldn't or shouldn't use this pattern, let's contrast it with another one

Contrast to Other Patterns
[Autogenerated] to contrast the command pattern. Let's compare it with thes strategy. The command is structured around an object per command or per request. The class contains the what essentially, what we're trying to do. It also encapsulate CE the entire action. The command object on Lee deals with this one exact scenario. Thes strategy, on the other hand, is similar to the command in that it is an object per request, with the focus on this pattern being per strategy different than the command. Though thes strategy focuses on the how rather than the what. Instead of encapsulating the action, it encapsulates the algorithm. This structure of these patterns are very similar, though with just some slight variations.

Summary
[Autogenerated] to briefly summarize what we've learned. The command pattern is a great pattern. And possibly after the singleton, the second most used pattern. The command pattern encapsulate. Each request is an object. It's also very good at decoupling the sender from the processor. This is one of the key reasons for using this pattern. Overall, with the command pattern there very few drawbacks and, as mentioned, the pitfalls. Maybe just a reliance on other patterns. The command pattern is also often used when we need undue functionality in our application. The next pendant that we're going to look at is the interpreter, and we'll see how that helps us process things.
