Introduction
[Autogenerated] Hi, this is Brian Hansen, and in this module, we're going to look at the observer design pattern. The observer pattern is a decoupling pattern. When we have a subject that needs to be observed by one or more observers. Let's look at the considerations when choosing this pattern.

Concepts
[Autogenerated] the concept surrounding why you would choose the observer pattern are that when you have a situation where a subject has one too many observers, this is generally when we're trying to decouple objects. Usually we will use this pattern but are not limited to situations where we need event handling capabilities. Some people use the term publisher subscriber interchangeably with the observer pattern. But there is some debate here. The observers typically used in a synchronous fashion where the pub sub model is typically used a synchronously. This pattern is most often used in NBC situations, where the view is event driven. Examples of this in the job, a p i. R. The observer pattern just like the generator pattern that we covered earlier in the course, the creators of Java felt like the observer pattern was useful enough in an abstract way that they baked this functionality into the core. A p I. The job you till event listener is the base interface for virtually every event, an event listener and ate a beauty and swing. This same pattern is also used in J. M s when implementing topics for message driven applications. Let's look at the design of this pattern

Design Considerations
[Autogenerated] the design of the Observer is that of a subject that needs to be observed. The subject is typically an interface or abstract class that we make concrete implementations off. The subject is a class that observers will then register themselves with. The Observer Self is interface based with various concrete implementations and in the case of the Java Util observer implementation, the subject implements an observable interface. Concrete observers are typically views in an event driven application. The pieces of the UML diagram are a subject, a concrete subject observer and concrete observer. Let's look that UML diagram now.

Pitfalls
[Autogenerated] What are some of the pitfalls of the observer? Well, since the subject doesn't know about its observers, there could be unexpected updates. An object can notify that it has changed without knowing what has changed. This leads to the next point, and that is of large update consequences. If an object is really large and we traded an update that forces that change, there can be a performance hit, even though we may not necessarily want update. I think of it in terms of something like files and notifying a change in a file for copying 100 make file every time something's been updated, we might not always want to do that. Although not using this pattern isn't going to make that risk go away, either. It's just something to consider when you're implementing it. Overall, just not knowing what has changed With this disconnected system, it can be confusing as to what has changed in that subject that signified such event to be updated. This disconnected nature can makes debugging often difficult and a little bit troublesome to work through

Contrast to Other Patterns
[Autogenerated] to contrast The Observer. Let's compare it with the mediator. The Observer is a one too many pattern. We have one subject and many observers of its state. It is primarily used to decouple an object from those that want to watch it. One of the key difference is is that it's uses a pub sub array broadcast communication mechanism. The mediator, though, is more of a 1 to 1 too many model and an object talks to a mediator, and then the mediator is in charge of communication with other objects. It's also used for decoupling but usually used for handling complex communication in a more direct model than that of a published subscriber at pub sub model. It should be noted, though, that the mediator can be implemented with an observer in the notification mechanism. The mediator would simply be part of our subject and to take our Twitter example a little bit further. That's actually how we would probably implement something like that in Twitter is our client would communicate with a mediator, which then in turn would broadcast through an observer

Summary
[Autogenerated] Let's briefly recap what we've learned about the observer pattern. It's one of the first patterns that I learned when first learning about patterns, and I really like it. It really strikes home. And I, like the publisher, describe broadcast model of the observer pattern. It's often used for decoupled communication where we have these objects that we want a broadcast stuff, too, and they don't necessarily know about one another. Our phone doesn't necessarily have to know that our tablet updated our Twitter feed. It's got some built in functionality in the job. A P I, the creators of Java, thought that this pattern was important enough that they built that into the job a P I and it typically could be used with and should be used with the mediator. If your case warrants it, I wouldn't shy away from using those two patterns together. If you're in a very complex situation that might benefit from both models, the next pattern we're going to look at is tthe East eight pattern, which we use to encapsulate the state of our application inside of an object
