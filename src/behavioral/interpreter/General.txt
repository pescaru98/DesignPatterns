Introduction
[Autogenerated] Hi, this is Brian Hansen, and in this module, we're going to look at the interpreter design pattern. The interpreter pattern is a behavior pattern that you used to represent the grammar of a language. A lot of tools use this pattern when parsing various aspects of a grammar. Let's look at some of the concepts considered when choosing this pattern.

Concepts
[Autogenerated] the concept surrounding why you would choose the interpreter pattern or that it represents a grammar. This could be music notation or mathematical equations, or even another language. Compilers will use the interpreter pattern too often. Times par source code. This goes hand in hand with representing the grammar, but we can then use it to interpret a sentence. This enables us to map out a domain specific language. If you've ever used Sequel or an XML par sir, this is the exact thing that is. This pattern was designed to dio define a language that can be interpreted to do things you'll often see an interpreter used when defining an abstract syntax tree or an S T. As it's often abbreviated. To examples of this in the Java A p I. R. The Java Util pattern, the pattern classes used to represent a compiled regular expression, it is an incredibly powerful way to search through strings. Another representation is tthe e java dot text dot for mat class format is an abstract based class that is used to represent locale sensitive content such as dates, numbers and strings. Let's look at some of the design considerations when choosing this pattern

Design Considerations
[Autogenerated] the design of the interpreter is quite a bit different than most of the other patterns that we've looked at. There is an abstract based class or an abstract expression that declares an interface for executing an operation. That operation is an interpret method. Expressions are then broken into terminal expressions, which represent a leaf of a tree or an expression that does not contain other expressions. If it does contain other expressions than it's a non terminal expression. Non terminal expressions represent compound expressions and continue. Clea called itself recursive lee until it finally represents a terminal expression or multiple sub expressions. The pieces of the UML diagram are the context, abstract expression, terminal expression, non terminal expression and a client. Let's look at that UML diagram now.

Pitfalls
[Autogenerated] Now that we've created our own interpreter, let's look at some of the pitfalls of it. If the grammar becomes very complex, it can be difficult to maintain, as you noticed in our rule example that we had you could see very quickly that if I started adding these different answer or combinations, it could become a little bit interesting to try and debug and walk through. So complexity can be an issue there. There is at least one class per rule, so every time we create one of our new expressions were creating another class. Complex rules will require multiple classes to define them. That's where the difficulty of maintenance can come into play. Use of other patterns might help with your specific implementation of a complex interpreter, and adding a new variant requires us to change every variant of that class. The interpreter is a little unique compared to some of the other patterns that we have looked at because it is fairly specific to the problem that we're trying to solve to better understand when we should use this or a different pattern. Let's contrast it with the visitor pattern

Contrast to Other Patterns
[Autogenerated] to contrast the interpreter pattern. Let's compare it with the visitor. The interpreter and the visitor are very similar in structure, but a different focus on implementation. The interpreter has access to properties because it contains the object. Functions are defined as methods, and since we extender implement the base interface, each interpret function is contained within a method. One drawback is that adding new functionality changes every variant recall the demo that we coated together when we were building the expression tree and the complexity that we could get by calm pounding those expressions together, the visitor is actually very similar to the interpreter, with some slight variations. Instead of having access to the properties we need, we have to implement the observer observable functionality to gain access to those properties similar to the interpreter. Functionality is found in one place, but it is in the visitors and not in the expression objects that were building and just like the interpreter. Adding a new variant requires changing every visitor. The focus is more about whether you're adding more expressions or grammar rules or adding new visitors to interact with, and that is the main focus on choosing one over the other

Summary
[Autogenerated] to summarize the interpreter pattern. You want to use this pattern when you're defining a grammar. It is a great pattern if you're defining rules or validation criteria for objects. Our example use strings, but you could just as easily substitute objects and take advantage of the power of generics inside your interpreter pattern. This pattern is more of a special case or limited use pattern. No, it solves a very specific problem. It's great for that purpose, but limited use outside of that watch when you're implementing it, to see where you think change is likely to occur, and you may want to consider using the visitor pattern depending on where that change is, The next pattern that we're going to look at is the generator pattern, which is a great one for cycling through objects.
