Introduction
[Autogenerated] Hi, This is Brian Hansen. And in this module where you're going to look at the chain of responsibility design pattern, the chain of responsibility pattern is a behavioral pattern that d couples a request from a handling object in a chain of handlers until it has finally recognized.

Concepts
[Autogenerated] the concept surrounding why you would choose the chain of responsibility pattern or they want to decouple the sender and receiver objects often times in an application. We want to pass a request to a receiving object without knowing who the center was and vice versa. The center shouldn't have to know who the receiver was in order for to process that request. When using the chain, the receiver should also contain a reference to the next receiver or the successor. This is an important part when choosing and implementing this pattern. It doesn't know the whole hierarchy, but it does know who's next in line. One of the main reasons for choosing this pattern is to promote loose coupling. We can modify the chain and add links to the chain without rewriting large portions of logic in the application. It should also be okay that there may not be a handler for a given request, and the application will just continue on examples of this in the job, a p i. R, the Java Util, logging Logar, a p I and although not part of the core job, a p i thes serval ap I specifically filters is another great example of chaining one of the best examples I've seen This pattern in use, though, is how spring implements their security chain filter in spring security. It's a great example of chaining.

Design Considerations
[Autogenerated] the design of the chain Responsibility has a chain of receiver objects. This can be implemented in a number of ways, but some basic form of a list is typically the most common. Each handler is based off of a main interface that defines the contract between each chain link. There is a concrete handler for each receiver or implementation that will interpret a request in building the chain. Each handler has a reference to its successor or the next link in the chain. The pieces of the UML diagram are a handler and a concrete handler and then its successor. Let's look at that UML diagram now.

Pitfalls
[Autogenerated] Now we've seen how great that chain of responsibility pattern can be. We did start to touch on some of the pitfalls or problems with this pattern. Let's go into that a little bit deeper. One of the pitfalls that you run up against is tthe e handling handler guarantee. We aren't guaranteed that someone along the chain will in fact handle our request. This is a direct reflection of our runtime configuration. We have great flexibility with this configuration, but it could mean that there's some configurations that haven't been tested and something might not get processed. There is also a concern about chain length as well. If you just keep tacking on handlers, it can get quite large, and the performance could start to degrade. This usually isn't a problem in my experience, but it is something to keep in mind. Let's go and compare this with another pattern. Know to see what it might be a good idea to choose it or something else

Contrast to Other Patterns
[Autogenerated] to contrast the chain of responsibility pattern. Let's compare it with the command pattern. The chain of responsibility is a pattern that deals with handlers, and each one of those should be unique. They also know about their successor. This is key because the pattern doesn't know about other commands surrounding it. The chain of responsibility will pass it on to its other successor, for it doesn't know what to do with it. The chain can oftentimes also utilize the command pattern in its implementation of those individual concrete handlers. The command pattern is actually quite similar to the chain responsibility and that its commands are also unique, just like the handlers. It's different, though, and then it it should encapsulate all of its functionality. It doesn't attempt to hand it off to somebody else if it doesn't know what to do with it commands air, also reversible or trackable in nature. We will often store a history of commands, and we don't do this with the chain of responsibility. In fact, that is a risk, as we mentioned in the pitfalls that we could have a chain not handle a request. It all and we don't know about it Although the pattern doesn't enforce this, we usually call a command because we know it will handle it. But the chain, we just send it down the chain, assuming that somewhere somebody along the way will handle it.

Summary
[Autogenerated] Let's just recap what we've learned with the chain of responsibility pattern It d couples, thesent er and receiver from requests. So the center doesn't have to know who's going to handle its request, and the receiver doesn't have to know who the sender was necessarily. You can configure this at runtime, and that can be helpful, or it could be dangerous as far as your applications concern. Usually that flexibility is looked upon as a positive thing, though it is high article in nature. In other words, it's going to build a zit goes down the chain As to who may be able to handle that request. You do have to be careful with large chains because it can become a performance bottleneck. Or it can be confusing where that business logic might be configured inside that chain. The next pattern that we want to look at is the command pattern in the command pattern shares some of the similarities, as we mentioned in the contrast section of this course

