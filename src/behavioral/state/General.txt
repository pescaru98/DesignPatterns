Introduction
[Autogenerated] Hi, This is Brian Hansen. And in this module, we're going to look at this state design pattern. The state pattern is as it sounds used when we need to represent state in an application.

Concepts
[Autogenerated] the concept surrounding why you would choose the state pattern. There. You want to localize state specific behavior. More specifically, the state pattern makes it so that your current application's state is stored in an object rather than a mix of variables throughout your application. The state pattern also helps us separate what state we're in from where we're at in our application. It effectively makes your objects follow the open, close principle of software design. The class is closed for changes, but the states are open to extensions. Examples of this in the job a P I. R. Actually, none of all the patterns There really isn't a good example of the state pattern in the core, a p I. There is an instance of this pattern in JSF, with its life cycles and phases, and some people argue that the Liberator implementations are implementations of state pattern. But I don't feel that they really are The reason, they argue this is that because it can change objects behavior runtime based on its state. Let's look at some of the design considerations when choosing this pattern

Design Considerations
[Autogenerated] the design of the state is abstract class or interface based. More often than not, this pattern is implemented with an abstract class. Because of the various states, an object can be in don't necessary apply to every instance of the state class and a rather just a default implementation. Each state is then class base and represented by an individual concrete class per state. The context or subject that has multiple states is unaware of various states using this pattern where before it knew all of those pieces. If this sounds a little bit complex, look at it this way. Before the state pattern. One object had a very large, if then else diagram, innit? That went through all the different cases that we could have inside of our application. Whereas once we implement this pattern that's externalized into each condition being its own state class, the pieces of the UML diagram are a context, a state and then the individual concrete states. Let's look at that diagram now

Pitfalls
[Autogenerated] Now that we've seen, how do you convert an application to use the state pattern? Let's look at what some of the pitfalls are. You must know all the states of your application. This may seem obvious, but often times people don't go through the exercise of clearly identifying each state, and what is needed to revisit represent that state in an object. When implementing the state pattern, you will invariably end up with more classes than you would have if you had implemented with the more traditional, method based approach. This was even evident in our small example. Another thing that you need to be careful of is keeping logic in the state objects and not letting conditional logic creep back into the context. Another common misstep is not identifying what triggers a state change. In smaller examples, it's easy, but clearly identify what triggers that change in the state of your application

Contrast to Other Patterns
[Autogenerated] to contrast the state pattern. Let's compare it with the strategy pattern. The state pattern is interface based, with a collection of concrete states estate on. Lee knows about the next state that it can transition to each state is also contained in its own class. The strategy pattern is actually almost identical to the state pattern, but its focus is different in that it is on algorithms, or strategies instead of state representation. It is also interface based, just like the state pattern. But one major difference is that strategies don't know about the next state. Their algorithms are independent from one another. They also like the state, have a class per algorithm. As the state pattern has a class per state. The UML diagram is almost identical for the strategy pattern, as it is for the state pattern.

Summary
[Autogenerated] Let's quickly recap what we learned with the state pattern. It simplifies Psychlo Matic complexity, thus removing those, if else spaghetti code blocks that we have inside of our application. It makes adding additional states much easier instead of having to go through each. If else blocking our application weaken, just add a class and change the state before it to point to this one. One of the drawbacks is that there are more classes involved with the state pattern, but that's not necessarily a bad thing. They're typically lightweight, and they are definitely isolated and contained, representing that open, close principle that we talked about earlier and software design and it's very similar and implementation to the strategy pattern. The two UML diagrams are honestly identical, and their focus is very similar. The only difference being is one's focused on algorithms where one's focused on ST with that comparison, let's look at the next pattern, which is thes strategy pattern
