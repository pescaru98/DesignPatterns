Introduction
[Autogenerated] Hi, this is Brian Hansen, and in this module, we're going to look at the visitor design pattern. The visitor pattern is a great way to separate an algorithm from an object structure. Let's look at the concepts when choosing this pattern.

Concepts
[Autogenerated] the concept surrounding why you would choose the visitor pattern or that you want to separate the algorithm from an object structure. There are many reasons as to why you might want to do this, but the key reason is typically that you are expecting a lot of change and adding new features and can't modify the existing object structure that you've already created. This approach helps us maintain the open closed principle in our design. The visitor class contains the changes and specializations rather than changing the original object. Examples of this in the job a p I r a little bit obscure, but actually our great implementations of the pattern the Java laying model element element class and its corresponding visit earthy element Visitor are great examples of this pattern, but they're typically used for the internals of language itself and processing. How the language gets compiled, interpreted. Let's look at the design considerations of this pattern now

Design Considerations
[Autogenerated] the design of the visitor is interface base. There is a twist with the visitor pattern, though, and it is that we must design around the visitor from the beginning. It's hard to retrofit after the fact the application has elements, and these elements are the pieces that we expect to change and need to add functionality to overtime. The way we add to this changes by implementing a visitor in each of the elements. Each element has a visit method, and each visitor knows of every element. The pieces of the UML diagram are a visitor, a concrete visitor, an element and a concrete element. Let's look at that UML diagram now.

Pitfalls
[Autogenerated] What are some of the pitfalls of a visitor? You have to plan on adaptability. This could be a little bit troublesome and lead toe over architect. In your application, you may build inflexibility that has never needed nor used. Thean direction of working with an object outside of its domain can be a little confusing as well. Each visitor may not implement all of the methods, so you may want to implement the adapter pattern. This isn't much of a pitfall, but it does add to the complexity of the visitor. We cover the adapter and an earlier module, and to solidify the usage of the visitor, let's contrast it with another pattern.

Contrast to Other Patterns
[Autogenerated] to contrast the visitor. Let's compare it with the generator. The visitor is interface based. Its focuses on adaptability through Externalizing changes, adding visitors is easy and encouraged. The interrogator, on the other hand, is also interface based but is typically implemented using an anonymous in her class. The IT aerator encapsulates navigation but doesn't necessarily externalize it. Although weaken implement multiple types of it aerator, we typically only have one inside of our application.

Summary
[Autogenerated] Let's do a brief recap of what we've learned with the visitor pattern. We want to use this pattern when we're expecting changes inside of our application, but we don't necessarily know what they might be up front. It does add a touch of minor complexity to the application, but nothing outside of standard object during innit principles. And we use this pattern when we want to externalize change. So if we can't change the base a p I once we've deployed it, the visitors a great way to go ahead and add functionality without changing what we already have inside of her application. It's also a great way for us to have tests inside of her application that we're not breaking the contract with by adding functionality down the road.
