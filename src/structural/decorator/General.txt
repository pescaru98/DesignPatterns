Introduction
[Autogenerated] Hi, This is Brian Hansen, and in this module, we're going to look at the decorator pattern. The decorator pattern is a hierarchical type pattern that builds functionality at each level while using composition from similar data types.

Concepts
[Autogenerated] the concepts surrounding why you would choose the decorator pattern are when you want to wrap another object. To add functionality to it, you can add behavior to an object without affecting other parts of the hair key if you don't want to. It is more than just simple inheritance, though you are controlling which pieces complement your object, not necessarily trying to override it. Like with inheritance. The decorator also follows the single responsibility principle, which states that every class should have responsibility over a single part of the functionality provided by the software. And that responsibility should be entirely encapsulated by the class. Basically, this means that it should do one thing and do it well. You can compose behavior dynamically by using one of the sub classes that decorate your object. This candidly makes it feel a little bit like a creation all pattern, but it is adding behavior through creations, so it is in fact still a structural design pattern. Examples of this in the a p i. R. The Java Io input stream classes, and these are a great example, often confusing to people as to why it does things the way that it does But hopefully this tutorial and walking through an example of it will clear up why they built it the way that they did the job. You till collections AP. I also has a checklist method, but it's not really clear is to why that is a decorator. Patterns were not going to use that for our example. And also, I should note that almost all you I components in the A, B, T and swing AP eyes are implemented following a decorator pattern.

Design Considerations
[Autogenerated] the design of the decorator is that it is inheritance based. Often the confusing, confusing part of a decorator is that it is more than just inheritance. It utilizes composition and inheritance. To achieve this, there is a common component, but functionality is added in the sub components. It is also an alternative to sub classing because it adheres to the single responsibility principle that we talked about in the concept section where this class will just do one thing. Typically, when you're subclass, it is to completely rewrite or extend the parent class. The last piece is that the constructor requires an instance of the component from the hierarchy, which enables it to build upon that and use composition rather than inheritance, to override which individual fields that it wants to. The pieces of the you are of the UML diagram are a component concrete component decorator and a concrete decorator. Let's go ahead and look at that example now to see what the UML diagram looks like

Pitfalls
[Autogenerated] What are some of the pitfalls of a decorator? You end up building a new class for every feature that you want to decorate, realized that the decorator enables us to not need to extend the concrete object but rather implement a new decorator itself. The side effect of this, though, is that you end up with a lot of little specialized objects. Decorators can also be confused with simple inheritance. In Java, you only have single inheritance, and some features shouldn't be part of the hierarchy. Decorators give us a unique way to add functionality without creating concrete objects. For every feature that we want to implement, we rather create a decorator and don't mess up that hierarchy of our concrete objects.

Contrast to Other Patterns
[Autogenerated] to contrast the decorator. Let's go ahead and look at the composite. And if you just finished the composite module, I'll be honest with you. This is the exact same comparison that we made earlier. The composite is a tree structure, and its intent is to make a leaf and composite have the same interface. The client. It provides a unity between objects. The decorator, on the other hand, contains another entity. Now this may sound a lot like a composite, but it is really composition. As you saw in some of the life examples that we did, we utilize both inheritance and composition. Composition just contains another entity in It differs in that it modifies this behavior of that contained entity. So we want to use decorators to modify that behavior of the contain entity. This is usually adding functionality to nitty that it didn't originally have, and we just want to decorate the underlying object, but not necessarily change that concrete class