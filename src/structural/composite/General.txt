Introduction
[Autogenerated] Hi, This is Brian Hansen, and in this module, we're going to look at the composite design pattern. The composite pattern is a hierarchical, tight pattern that deals with tree structures of information.

Concepts
[Autogenerated] the concept surrounding why you would choose the composite pattern are that it is meant to treat components the same, whether it is part of your structure or the whole structure itself. This is done by configuring your objects into tree structures. Once your data is built this way, you can treat individual objects the same as a composite object and treating objects the same. We can apply operations or functions on both the individual and the composite and expect them to work the same way. Examples of this in the job a P I. R. Java, a WT component Almost everything from the Java Ada beauty library is built this way as well as JSF widgets. Now JSF isn't part of the core AP I, but almost everything in Java server faces is built around the same structure. Another useful example is rest ful Web services. In fact, the way we structure gets are almost always built with the composite structure in mind. So if you've never used a rest full service, don't worry about it. But there is a couple, of course, is out here on portal sites, specifically one on wrestle services using Jersey that talks about how we navigate and re cursed down through the directory structure. Using this composite model

Design Considerations
[Autogenerated] the design of the composite is that it is tree structured. The root of the tree starts with a component. Components are one of two things either a leaf or a composite of objects. The difference is that a leaf just has operations and a composite has all of the same operations available, but also knows about its child components. The pieces of the UML diagram are a component, a leaf and a composite. Let's look at that UML diagram now.

Pitfalls
[Autogenerated] what are some of the pitfalls of a composite pattern? It can overly simplify a system. This may seem like a strange drawback at first, but in building the hierarchy the way that we want to do it, it could make it difficult to restrict what we want to add to it. Everything eventually has treated the same, and that is the intent of the pattern. But you end up relying on runtime checks to see if objects being added can in fact be added instead of compile time. Safety implementation can also be costly of dealing with a very large composite or, if implemented, correct, incorrectly. This doesn't have to always be the case. But if child objects air held in a collection and each object itself contains a collection, it's size. Congrats fairly quickly. Typically, composites aren't that big, though, and I don't find this being a real practical issue.

Contrast to Other Patterns
[Autogenerated] to contrast the composite pattern. Let's compare it with the decorator. The composite is a tree structure. Its intent to make a leaf and a composite have the same interface to the client. It provides a unity between objects. The decorator, on the other hand, contains another entity. Now this may sound like a composite, but it really just composition composition is just an object containing another one. It differs in that the decorator modifies the behaviour of the contained entity. This is usually adding functionality to an entity that it didn't originally have. It decorates the underlying object but doesn't necessarily change it.

Summary
[Autogenerated] let's do a quick recap of the composite pattern. The composite pattern generalizes a hierarchical structure. As we saw on our examples. We built a menu structure that had menu items such as leafs and other composites, and it helped us navigate that structure in an easier fashion. It can simplify things too much. As we learned in the Pitfalls section, you can make things too overly simplistic, which can later make it harder to restrict what's getting added to a menu. And you can sometimes have to rely on runtime checks. It definitely makes things easier for the client. In our example, we looked at the client, didn't it? Didn't care if we had a menu, a sub menu, a menu item. It just handled it all gracefully the same way. Likewise, with our our collections example, we went through and could add individual items or an entire collection, and it gracefully handled both as well. The last thing that we should talk about is the composite does not equal composition difference. The composite pattern is dealing with that hierarchical structure where composition is just one object containing another, and I bring this up because the next pattern that we're going to look at is the decorator pattern, and the decorator pattern utilizes composition, but it is not a composite structure.
