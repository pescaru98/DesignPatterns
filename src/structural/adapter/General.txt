Introduction
[Autogenerated] Hi, This is Brian Hansen, and in this module, we're going to look at the adapter design pattern. The adapter pattern is a great pattern for connecting new code to legacy code without having to change the working contract that was produced from the Legacy code originally.

Plug Adapter
[Autogenerated] just to get it out of the way. It seems that everybody wants to describe the adapter pattern as a concept of a plug adapter. We have a device that needs to plug into an outlet, and we can use an adapter to make that connection. This is a fairly accurate description, but there's some twists to the adapter pattern that the typical plug example doesn't cover. And, frankly, it isn't a software example. One specific thing that I don't like about this example is that we usually only look for or need one adapter with the plug example. And with software, we could have multiple adapters. So there's one variation there that you should keep in mind that the plug adapter doesn't really demonstrate very well.

Concepts
[Autogenerated] We already talked about the notion of a plug adapter, but let's dive into more detail about the concepts surrounding the adapter pattern. We would choose this pattern when we're wanting to have a client talk to an existing inter vase. This is usually the case when one portion of our system is a legacy, app or module. That we don't want to or can't possibly change it effectively is translating request from the client to the code that we're adapting to basically a client to talking to a legacy app or on adapt E that we have used an adapter to talk to. Examples of this in the job. A p i. R. The collections AP I specifically the usage of the arrays to lists conversion arrays were original, or you could classify as a legacy a p I and list where the newer part of the collections AP I introduced later their methods in the collections a p I to adapt a raise to lists. Another example in the job, a p i. R. The stream classes surrounding Io. Almost all of the stream classes have adapters to work with other streams or readers

Pitfalls
[Autogenerated] What are some of the pitfalls of the adapter? Well, not a lot, actually. Don't over complicate them. Typically, an adapter would provide multiple types of adapters. That doesn't mean to say that if you only have one adapter, that it isn't an example of the adapter pattern, but more to point out that you may or may not be using the pattern correctly. The adapter is also used to make things work together. If you are adding functionality to your legacy code to the adapter, then you should probably be considering the decorator or some other type of structural pattern.

Contrast to Other Patterns
[Autogenerated] to contrast the adapter pattern against another one. Let's compare it with the bridge. The adapter makes things work after they were designed, basically dealing with legacy code. The adapters, almost always retrofitted to make unrelated classes work together. It is essentially created to provide a different interface to our legacy code than was originally intended. The bridge, on the other hand, was designed up friend to let abstraction and implementation very independently. It is built in advance so that we can provide a layer of a distraction and let both systems be flexible while we are implementing and creating them. Both the bridge and the adapter are meant to adapt multiple disparate systems and work in concert with one another.

Summary
[Autogenerated] Let's briefly recap the things that we've learned while implementing the adapter pattern. It is a simple solution. Teoh A very descript problem. Quite easy to implement. You saw how quickly we have implemented two different adapter patterns inside of our code. It is typically used to just integrate with legacy code that we can't or don't want to change. And usually this method or pattern will contain multiple adapters. So one common problem I see with people implementing the adapter pattern is that they create one adapter and then walk away from it. Don't be shy to look at other uses that you can utilize and extend your application with multiple adapters to interface with those legacy APIs