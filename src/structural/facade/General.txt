Introduction
[Autogenerated] Hi, This is Brian Hansen, and in this module, we're going to look at the facade pattern. The facade pattern provides a simplified interface to a complex or difficult to use system that is often the result of a poorly designed A P I.

Concepts
[Autogenerated] First off, it should be noted that the facade pattern is pronounced facade and not FIC aid. This is a common mispronunciation. When discussing this pattern when going to a job interview, make sure you call it the right name, the concepts surrounding why you would choose the facade pattern or one thing you want to make an A P I easier to use. Oftentimes you encounter a poorly designed A P I and can wrap a facade around it to hide the details from the client. It also helps to reduce dependencies on outside code. The main point that I usually look for is that it will simplify the interface or client usage. We typically want to wrap complex code with an interface using this facade to make it simpler for the end user. It should also be thought of as a re factoring pattern. You would usually want to implement a facade to wrap a poorly or complex written a p I. Examples of this in the job a p i. R java dot net dot u R l. There is a lot of functionality built behind the Ural class, and it provides a simple interface to the end user. There actually aren't a lot of good examples of the facade in the J via Java, a P I. And that is probably a good thing because is usually the result of a poorly designed or complex AP I. But another good example of the facade pattern is the Java server faces a P I specifically the faces context Now faces is part of the J two ee pattern, so we're not gonna talk much more about that. But suffice it to say that Faces has a fairly complex A p I, and interacting with the context can be quite difficult. So this is a great example of the facade pattern as well.

Design Considerations
[Autogenerated] the design of the facade is actually quite simple. It is a class that utilizes, typically just composition in its design. You shouldn't have a need for inheritance, and if you feel like you need to, then you probably ought to be looking at a different design pattern. The facade also encompasses the entire life cycle of whatever object you're dealing with, but it doesn't necessarily have to in order to be considered a correct usage of this pattern. The UML pieces associate with this UML diagram are simply a class and the packages or classes that the facade is making easier to use. Let's look at that UML diagram now.

Pitfalls
[Autogenerated] what are some of the pitfalls of the facade? It's typically used to clean up code that was potentially designed incorrectly or poorly to begin with. If you're using it, a new A P I or interface, you really should look at the design of your A P I and see if another pattern will help solve the problems that you're trying to solve with the facade. It typically shouldn't utilise inheritance, so the facade deals with a flat problem or structure, and it is a It is the single 10 of structural patterns. And what A. What I mean by that is that it often is misused or overused because it's such an easy pattern implement You saw through our example. We just put a basic class in and masks some of those things that were going on behind the object behind it. It's an interesting pattern in the sense of object oriented programming, because it's just dealing with making a simpler interface to that client. But you can see how people often over use it or misuse it to just hide some of those ugly things that they've designed into their code. And if you're doing that up front, you probably need to think about the design of what you're trying to do inside your application

Contrast to Other Patterns
[Autogenerated] to contrast the facade pattern. Let's compare it to the adapter pattern. The facade patterns simplifies an interface, and it works with, typically just composite. It provides a cleaner a P I, to something that was designed incorrectly or complex Lee to begin with. The adapter, on the other hand, is also a re factoring pattern very similar to the facade, but it modifies behavior and typically is used toe add behavior to an object. So with the facade, we're just trying to clean up its usage. Where the adapter is adding behavior to the object that we're working with. It also provides a different interface to code. So the adapter is trying to maybe bring an A P I or an interface up to something more current in your application, where the facades just trying to make it easier to work with

Summary
[Autogenerated] So let's briefly recap what we learned with the facade pattern. It simplifies the client interface, and that's really the Onley. And main goal of this pattern is to make things easier and hide some ugly nuances of an A P I. It's a very easy pattern to implement. As I mentioned in the pitfalls, It kind of is the singleton of the structural patterns, because people can see how it will help and see how to utilize it so they get a little carried away with it sometimes. But it is a simple one to add to your code and something that you should consider in trying to re factor things. And it's definitely a re factoring pattern. This isn't something you should design in upfront. It's something that you want to use down the road after you realize that. You know this code is ugly and we're passing all this stuff down to our client to utilize. Let's go ahead and put a layer here so that we can reduce those dependencies that the client is necessarily looking at is you'll notice in our JBC demo, our client had to know about connections, statements, results, sets and all that type of stuff, and after we put our facade in filling and he didn't know about was our facade, it didn't need to know about any of the exception or exception handling or connections that were going on behind the scenes. So it's a nice way to clean up that stuff and reduce those dependencies inside of our application.
