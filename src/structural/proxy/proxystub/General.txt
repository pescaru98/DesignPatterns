Introduction
[Autogenerated] Hi, This is Brian Hansen. And in this module, we're going to look at the proxy pattern. The proxy pattern is a pattern that acts as an interface to something else.

Concepts
[Autogenerated] the concept surrounding why you would choose the proxy pattern or what we want to wrap it really object with a proxy. For various reasons, you create an interface to an object by wrapping it with a class to create that proxy. It can also add more functionality to that wrapped object. Proxy could be used to solve multiple problems such as security or simplifying and interface to something a remote service call or just a expensive object to create. Well, oftentimes, rabbit with the project proxy and display loading message or something like that for a expensive object that we're trying to display to Are you? I or just loaded a memory. The proxy itself is called to access the rial objects will have an interface than a proxy that's wrapping the real object and then the underlying real object. Examples of a proxy in the Java empire actually kind of interesting. In different from some of the other patterns that we've looked at. The java dot lang dot reflect dot proxy object is a mechanism to facilitate creating proxy patterns using Java, so Java deep down, felt like this was an important enough concept that they create created a proxy class and object invocation handlers to facilitate creating proxies. And many of the frameworks you're used to seeing are built with java dot ling not reflect dot proxy. Also, the whole java dot r M I package is focused around proxy and remote method invocation. So as we looked at the concept above one of those being remote, the Java Dot are in. My package is all about accessing remote objects and retrieving that data across the wire.

Design Considerations
[Autogenerated] The design of the proxy is simple in concept, but it could be utilized in many different ways. The basis for it is an intermediary object that intercepts calls. That being said, it is typically interface based. Many frameworks like spring and some uses of hibernate and other various dependency injection frameworks use it and in doing so typically have an interface and an implementation class that the proxy resides in between the job, the A P. I recognize the need for the proxy pattern and incorporated an interface. The invocation handler and a class the java dot Laing don't reflect up proxy class to facilitate this. The pieces of the UML diagram are a client, an interface invocation, handler proxy and its implementation. Let's look at that UML diagram now.

Pitfalls
[Autogenerated] What are some of the pitfalls of a proxy? Well, you can Onley have one proxy. So if we want to implement security and auditing, we have to do it in that one proxy. We can't separate those out. Some other patterns allow you to change or rap. When you use the proxy, though you can only have that one instance, it also adds another abstraction layer. Now some might argue that this isn't a bad thing, but it can lead to other issues in case of like a remote proxy. If you believe you're accessing something local and it is in fact remote, you might get errors that you wouldn't maybe be expecting. It's also really similar to other patterns now. This may not seem like much of a pitfall, but it can be a little bit hard to identify. If you aren't familiar with the alternatives that you need a proxy instead of, say, a decorator or an adapter of sorts, it is easier if the proxy is for a remote object, but you can see how this can had a little confusion. If you're trying to determine which pattern you should be using,

Contrast to Other Patterns
[Autogenerated] to contrast the proxy. Let's compare it with a decorator. The proxy can add functionality, but it's really not its main purpose. We can really only have one proxy for that class instance, and it is. Functionality is set at compile time. It's not really the focus of what the decorator is. We are going to determine upfront what class were trying to call a remote call. Two or whatever other type of interface were trying to provide virtual or remote. The decorator, on the other hand, dynamically adds functionality. Its purpose is to add functionality and chain them as we go. They are a chained pattern, as I mentioned to. It also always points to its own type, where a proxy is intercepting a call to some different subclass or subtype. A decorator is usually looking at something else, and it's High Article chain, and the other contrast is that its functionality is usually determined at runtime instead of compile time like the proxy, we're gonna go ahead and change these things together at run time, and that object will figure out then what it can dio

Summary
[Autogenerated] Let's go ahead and recap what we've learned about the proxy pattern. There's great utilities built into the Java A P I. To implement the proxy pattern. You can see there's the proxy class, and the invocation handler interface would make it really easy for us to implement this pattern inside of Java. One drawback to it is that you only get to use one proxy per object. You're trying to proxy, too, so you can't chain them or build upon them. So if you have to add things to it, you might get some bloat inside that proxies or adding different features to it. I should also point out that this is used a lot by various dependency, injection and inversion of control framework. So a few years in spring or juice or tools like that, we briefly touched on it. But this is this technique, or this concept is used a lot in there. One thing that people often think of that this pattern is that it's a great way to just implement lazy loading, which that really doesn't have a lot to do with the proxy pattern. But you can see how out of minimum that's what it could be used for. I like to use this pattern a lot when you're intercepting a call to maybe go out to a remote server and return that instance in there and not have all that code cluttered inside your object or how that gets handled.
