Introduction
[Autogenerated] Hi. This is Brian Hansen. And in this module, we're going to look at the bridge design pattern. The bridge pattern is very similar to the adapter, with the main difference being that the bridge works with new code, whereas the adopter works with legacy code.

Concepts
[Autogenerated] the concepts surrounding why you would choose the bridge pattern or that it is meant to decouple abstraction and implementation. To do this, you utilize a few techniques, namely encapsulation, composition and inheritance. A key concept with the bridge pattern and why it is more than just inheritance is that changes in the abstraction won't affect the client. What is meant by this is that the client is unaware of the abstraction on the back end. This is important because this d couples the implementation from the contract or interface that the client is using. One of the key reasons for choosing this pattern is that we know the details won't be right to begin with. This may sound a little strange at first, but the bridge allows for a level of indirection that we add into our application. If you aren't quite sure of what the end product of what you're building will be. The bridge is great for giving us flexibility without breaking things with change. Examples of this are drivers. We use drivers all the time and the bridges and the bridges in a lot of ways. Just a driver. A good example of this in the job a p i. R J D B C drivers. We have an interface that we work with and a driver that works with the underlying database.

Design Considerations
[Autogenerated] The design of the bridge is more complicated than the adapter. It will utilize interfaces and abstract classes. It also places an emphasis on composition over inheritance. But it is more than just composition. Your application is designed to expect change from both sides. Normally, the UML for this pattern would be on this slide as well, but it is too large and will be on the next diagram. The pieces of the diagram are an abstraction, implement or refined obstruction and a concrete implementer. Let's look at that diagram now.

Pitfalls
[Autogenerated] what are some of the pitfalls of a bridge? It does increase complexity. Also, as we saw with the color and shape example, you need to look at the code and see what makes sense to abstract out. It can be conceptually difficult to plan. Your code needs to be fairly thought out, and it might not lend itself into an agile codas. You go scenario. It is definitely more than just good. Oh, principles. One comment that has often made about design patterns is that I use sound oo principles and I don't need to know patterns. Well, this is more than just inheritance and abstraction, and overall, it could just be a little confusing as to what goes where in your code.

Contrast to Other Patterns
[Autogenerated] to contrast the bridge pattern with another one. Let's go ahead and look at the adapter pattern. The bridge pattern is designed upfront. It's something we consciously go into our application with the mindset that we want to dio the abstraction and the implementation convey areas we saw with the demo that we did. We have our printer object in R four matter object, and we can change either side of those without breaking the other. It is definitely built in advance, just like it's designed up front. This is something we consciously build up front as well, and it is a little bit more complex. It adds a layer of complexity, which isn't necessarily a bad thing, but it is mawr complex than what we might just do out of the gate on our own. The adapter, on the other hand, works after the code is designed. It is intended for legacy applications. So it's something that we we try to tie in legacy code with a new application, and in doing so, it's typically retrofitted in. It's something that were working with, and we try and piece into our application later and really the ultimate design or point that we're trying to do with an adapter is just get a different interface for existing or legacy code. We're just trying to make this tie into something else that already exists and nothing more, nothing less. We're not trying to add any more functionality. Where with the bridge. We're trying to break that functionality apart so that we can make those change independently of one another.

Summary
[Autogenerated] to wrap up the bridge. Let's just quickly recap what we've covered. The bridge is designed for uncertainty. It can be complex and often times adds a layer of complexity to our application that we weren't planning on. It provides a level of flexibility, so we will take that complex city because it gives us flexibility. So it helps us in designing for the uncertainty of what we might do inside of our application and then to last, they just point out it is much more than composition. We do utilize composition. We also utilize inheritance through abstractions and interfaces Inside of our coats were really taking a lot of the principles of good oh design and wrapping them into this one pattern.