Introduction
[Autogenerated] Hi, This is Brian Hansen. And in this module, we're going to look at the flyway pattern. The flyway pattern is a pattern that minimizes memory used by sharing data with similarly type objects.

Concepts
[Autogenerated] the concepts surrounding why you would choose the flyweight pattern or when you need to make a more efficient use of memory. A flyway is definitely an optimization pattern. This is typically an issue when you have a large number of similar objects, and this is especially the case for objects that are stateless or immutable in nature. Immutable objects are objects that their state can't be changed after creation. This is possible when most of the objects state can be in tricks. Extrinsic, extrinsic properties are ones that are not essential or inherent. Examples of this in the job. A p i. R java dot Laing dot string strings are immutable objects and are loaded from a string literal pool that is basically the flyweight factory. Cashing is generally a hint also that you are, or could he be using a flyweight as well? There are quite a few other examples in the job, a P I, specifically java dot linda in Urge ER and the value of method, which is another great example of a flyweight. In fact, all of the primitive objects with rappers such as Boolean bite, character, short and long have a value of method that is similar to the inner jurors, one that is a flyweight in action

Design Considerations
[Autogenerated] the design of the flyweight is a little more complicated than some of the other patterns we've looked at. It is a pattern of patterns. It utilizes other patterns inside of it, so to speak. It uses a factory pattern to retrieve flyway objects after they've been created. The flyweight also often encompasses both the creation and structure of the object as far as the patterns concerned. So it has a creation all pattern inside of this structural pattern. It can and often does, manage the entire life cycle of the object. If you are unfamiliar with the factory pattern, you can watch the factory pattern module in the creation patterns course. The pieces of the UML diagram are a client factory flyweight and concrete flyweight. Let's look at that UML diagram now.

Pitfalls
[Autogenerated] what are some of the pitfalls of a flyweight? It is a bit of a complex pattern, as you notice is, we went through our example. There's Ah lot of little moving pieces to utilize it the right way, and you have to deal with a factory and some of the other pieces that you want to utilize just to take advantage of this pattern. I am personally not one that likes to prematurely optimize my code, and this is a pattern that you do that with. You are already planning up front for optimization. That's not necessarily a bad thing. If you've done a spike or you understand your product or architecture well enough that you know you're going to need to optimize upfront, then that's not necessarily a bad thing. But I often find that people figure that out later in their product lifecycle. Another pitfall with this is that you must understand the factory pattern now. That's not necessarily a bad thing, but if you have a pattern inside of a pattern, sometimes it can be a little bit confusing about which is the factory and which is the flyweight, and that the fly weights part of the factory of what? The factories returning and you get the example. It just becomes a little bit more complex. If you're looking at other examples out there. Ah, lot of them are graphical examples. Its value is well beyond graphical implementations. But a lot of research would lead you to believe that this is where it's on Lee Value is at. You can see through our example that we would utilize this in any sort of management system, you know, inventory management or a shopping cart system. Something to that nature where we have a lot of small objects that a lot of people will be utilising, and we need to take advantage of that memory management. So not just a graphical pattern, but a lot of the examples and samples you look at out. There definitely are graphical centric

Contrast to Other Patterns
[Autogenerated] to contrast the flyweight pattern. Let's compare it with the facade. And honestly, there aren't really a lot of other Strack structural patterns that are very similar to the flyweight, but this is a good one to compare it to. For various reasons, the flyweight is focused on memory optimization. It is by nature a optimization pattern and deals with immutable objects. The facade, on the other hand, is a re factoring pattern and is usually implemented after the fact. So the flyweight is definitely implemented upfront and early on. If not, you're going to be re factoring a lot of code where the facade is definitely something that's thought of after the fact. The facade is also centred around making a simplified client or making it easier for the client. Once we realize that the A. P I were dealing with his very complex in nature, it also provides a different interface. Its entire goal is a different interface for the client, where the flyweight was designed up front for the client to not know that that pattern was being utilized under the hood. All it knows is that it has an instance of whatever object it was trying to get so we would use a facade to provide a more simplified interface where the flyweight was designed up front to already deliver a simple interface to the client.

Summary
[Autogenerated] Let's do a quick recap of what we learned with the flyway pattern. It is great for memory management. It's a pattern that we want to utilize if we know we're going to have a lot of objects that were going to pass around in our system and don't want to create those for every client or end user that's going to be accessing them from our system. It can't be a little bit of a complex pattern to deal with unnecessarily bad once you know the details of it. But you have a factory pattern in there. At a minimum, you have to make your objects immutable, and you're dealing with all these small little objects and how you pass them around where a lot of times people haven't thought of in terms of composition, you're going to pass an object into an object, and that's going to be an instance of your flyweight. It is used a lot by the core AP I. So there are some great examples out there, and now you know what you're looking for. You'll see all the time that oh, I'm using the java dot langdon integer value of our byte value of our character value of her strings are all great examples of fly weights, and they're not just used for graphical implementations. The next pattern that we're going to look at is the proxy pattern if you're following along this Siri's and that's the last one for the structural patterns. So let's go ahead and take a look at that now.
